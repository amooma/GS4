<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="sicherheitskonzept-web-interface" xml:lang="de"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Web-Interface</title>

  <para>Wichtige Bausteine des Sicherheitskonzeptes beim Web-Interface und der
  Applikation sind:</para>

  <itemizedlist>
    <listitem>
      <bridgehead
      xml:id="sicherheitskonzept-web-interface-validierungen">Validierungen</bridgehead>

      <para>Validierungen der Attribute in den sogenannten
      <quote><foreignphrase xml:lang="en">Models</foreignphrase></quote> der
      MVC-Architektur. So werden nur gültige Werte zugelassen. Bei Zugriff
      über das HTML-Web-Interface sowie über die XML-API finden die gleichen
      Validierungen statt. Dies ist ein Baustein der Maxime „Security by
      Design“, d.h. es wird immer von absichtlichen oder unabsichtlichen
      Falsch-Eingaben ausgegangen.</para>
    </listitem>

    <listitem>
      <bridgehead
      xml:id="sicherheitskonzept-web-interface-tests">Tests</bridgehead>

      <para>Wir verwenden eine stetig wachsende Anzahl an automatischen
      Unit-Tests, die einzelne Komponenten testen, sowie Funktionstests, die
      die ordnungsgemäße Funktion der Controller testen. Dadurch ist auch das
      Einloggen am System mit eingeschlossen. Hier ein Beispiel als
      Auszug:<programlisting># Ein Admin darf eine Liste der SIP-Telefone anzeigen:
#
test "should get index" do
    sign_in :user, @admin_user
    get :index
    assert_response :success
    assert_not_nil( assigns( :sip_phones))
    sign_out @admin_user
end

# ansonsten darf keine Anzeige erfolgen:
#
test "should not get index (not an admin)" do
    get :index
    assert_response( @expected_http_status_if_not_allowed )
end</programlisting></para>
    </listitem>

    <listitem>
      <bridgehead
      xml:id="sicherheitskonzept-web-interface-authentifizierung">Authentifizierung</bridgehead>

      <para>Zur Authentifizierung der Benutzer kommt <quote><foreignphrase
      xml:lang="en">Devise</foreignphrase></quote> zum Einsatz (<link
      xlink:href="https://github.com/plataformatec/devise">https://github.com/plataformatec/devise</link>).
      Bei der Auswahl eines geeigneten Authentifizierungssystems für Ruby on
      Rails war uns wichtig ein populäres System zu wählen das sich in
      vielfachem produktivem Einsatz bewährt hat, das gut durch automatisierte
      Tests abgedeckt ist, das aktiv gepflegt wird und das bereits vielen
      Entwicklern bekannt ist. Devise ist ein modulares System bei dem man nur
      die Komponenten einbindet die von der jeweiligen Applikation genutzt
      werden. Zu den Modulen gehört beispielsweise <quote><foreignphrase
      xml:lang="en">Database Authenticatable</foreignphrase></quote>, das das
      Einloggen der Benutzer per Benutzername und Paßwort übernimmt. Die
      Paßwörter sind dabei in der Datenbank nicht im Klartext gespeichert
      sondern als SHA-Hashes (<link
      xlink:href="http://de.wikipedia.org/wiki/Secure_Hash_Algorithm">http://de.wikipedia.org/wiki/Secure_Hash_Algorithm</link>)
      die über Paßwort und ein zufälliges <quote><foreignphrase
      xml:lang="en">Salt</foreignphrase></quote> (<link
      xlink:href="http://de.wikipedia.org/wiki/Salt_%28Kryptologie%29">http://de.wikipedia.org/wiki/Salt_(Kryptologie)</link>)
      gebildet werden. Auf diese Weise kann selbst jemand mit Zugriff auf die
      Datenbank die Paßwörter nicht rekonstruieren, und durch das
      <quote><foreignphrase xml:lang="en">Salt</foreignphrase></quote> wird
      der Angriff mit <quote><foreignphrase xml:lang="en">Rainbow
      Tables</foreignphrase></quote> erschwert.</para>
    </listitem>

    <listitem>
      <bridgehead
      xml:id="sicherheitskonzept-web-interface-orm">ORM</bridgehead>

      <para>Kein SQL im Code. Durch die Verwendung eines Objekt-relationalen
      Mappers (ActiveRecord) besteht nicht die Gefahr daß durch Fehler im Code
      von Gemeinschaft4 Daten ohne Escaping in SQL-Statements landen, dadurch
      wird SQL-Injection verhindert. ActiveRecord selbst ist sehr gut getestet
      und tausendfach im Einsatz.</para>

      <para>Ebenso kommen Datenbank-Transaktionen zum Einsatz, also die
      Zusammenfassung von logisch zusammengehörigen Einzel-Operationen. Dies
      dient der Daten-Integrität durch Atomarität (<foreignphrase
      xml:lang="en">Atomicity</foreignphrase>), Konsistenz (<foreignphrase
      xml:lang="en">Consistency</foreignphrase>), Isolation (<foreignphrase
      xml:lang="en">Isolation</foreignphrase>) und Dauerhaftigkeit
      (<foreignphrase xml:lang="en">Durability</foreignphrase>).</para>
    </listitem>

    <listitem>
      <bridgehead
      xml:id="sicherheitskonzept-web-interface-saubere-schnittstellen">Saubere
      Schnittstellen</bridgehead>

      <para>Gemeinschaft4 verwendet durch die
      Model-View-Controller-Architektur definierte Schnittstellen.
      Gleichzeitig werden nach außen APIs im REST-Stil bereitgestellt. Ebenso
      wie für das HTML-Interface ist zur Benutzung der Schnittstellen eine
      Authentifizierung und Authorisierung erforderlich. So können weitere
      Konfigurations-Tools oder beispielsweise eine andere Applikation auf die
      Schnittstellen zugreifen ohne daß die Gefahr besteht, daß sich
      potenzielle Fehler in solchen „externen“ Tools auf den Kern des Systems
      auswirken oder daß &#8211; möglicherweise unbeabsichtigt &#8211;
      Zugriffsbeschränkungen umgangen werden.</para>
    </listitem>

    <listitem>
      <bridgehead
      xml:id="sicherheitskonzept-web-interface-https">HTTPS</bridgehead>

      <para>Verbindungen sollen immer über HTTPS erfolgen. Dabei ist zu
      beachten nur geeignete Cipher Suites auszuwählen, also geeignete
      Varianten aus der großen Menge der möglichen Verfahren beim
      Schlüsselaustausch, Authentifizierung, Hashfunktion und Verschlüsselung.
      Insbesondere bietet die sogenannte „Null“-Verschlüsselung, die
      prinzipiell von SSL/TLS unterstützt wird, keine Verschlüsselung &#8211;
      wie der Name schon sagt. Schlüssel unter einer Länge von 128 Bit sollen
      generell ausgeschlossen werden, ebenso wie die Hash-Algorithmen MD5 und
      SHA-1 (stattdessen: SHA-2-Familie). Natürlich dürfen nur solche
      Zertifikate akzeptiert werden, deren „<foreignphrase
      xml:lang="en">Chain</foreignphrase>“ (Kette) zur CA (<foreignphrase
      xml:lang="en">Certificate Authority</foreignphrase>) korrekt ist.</para>

      <para>Besonders schützenswerte Bereiche können zusätzlich durch
      Client-Zertifikate abgesichert werden. Der Zugriff auf so geschützte
      Bereiche ist dann nur mit einem im Browser installierten Zertifikat
      möglich. Wenn die Zertifikate auf einem gesicherten Weg verteilt wurden
      kann damit sichergestellt werden dass keine sensiblen Daten durch einen
      einfachen Passwortdiebstahl zugänglich sind.</para>
    </listitem>
  </itemizedlist>
</section>
